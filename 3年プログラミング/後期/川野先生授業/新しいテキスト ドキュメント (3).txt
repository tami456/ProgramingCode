文字コード Shift-JIS, UTF-8, UTF-16, UTF-32, EUC-JP
文字セット


そもそも「文字」というのは数値


8ビットマルチバイト
0～127
数字、アルファベット、演算記号
128～ + 8ビット = 全角

Unicode(まったく新しいコード)(wchar_t)
UTF-8(C++)
UTF-16(C#)
UTF-32(Android)

TCHARとは
マクロのこと
プロジェクトの設定がマルチバイトなら
TCHAR=char

Unicodeなら
TCHAR=wchar_t

文字列リテラル
"abcdef" ""で囲んだもの←char(マルチバイト文字列)

L"abcdef"←wchar_t(ワイド文字列)

実は両方対応できるマクロがあって、
_T("abcde")というのがあります
これは設定がマルチバイトなら
"abcde"になり
Unicodeなら
L"abcde"
になります。

char* str="abcde";
wchar_t* wstr = L"abcde";

str(char*)をwchar_t*に変換したい
Lstr←ダメ

C++14で血迷ってこの辺の変換を標準にしようとしたときがあった
ありましたが、すぐに「非推奨」になり
消えました。
→各OSのAPIでやってくださいというのが標準化委員会の見解です

なお、stringにもUnicode版があり、それは
wstringです。

これの変換関数を最初に作っておきましょう。


相互変換にはWindowの関数
MultiByteToWideChar
WideCharToMultiByte
を使用します

ただし、これの使い方がちょっとややこしい
wchar_t* MultiByteToWideChar(char*)
で返ってはこない。

ひとことで言うと2回呼ばなきゃいけない
1回目はワイド文字の文字数を返す。
この文字数をもとにワイド文字列の文字列数を確保します
確保したら、そのワイド文字列のポインタをもって
2回目の呼び出しを行います。

これで、確保した領域に変換後の文字列が書き込まれます。


stringの正体…
std::vector<char>に便利な関数がいくつかついただけのもの
便利な関数
c_str();//お尻に終端文字を追加して返す
length();//size()と同じ
+();//文字列を連結する
=();//文字列を代入する
==();//文字列を比較する


wstringの正体…
std::vector<wchar_t>に便利な関数がいくつかついただけのもの


std::pair<型1,型2>
firstが型1
secondが型2

std::make_pairとは、
std:pair型に対して代入できるペアを作るためのもの

make_pair(値1,値2);


vectorのpush_backは地涌はメモリ効率的にはあまりよくない
2～3要素ならまぁいいかなって感じなんですが、要素数
によってめちゃくちゃ高いコストを支払うことになります。
	①新しくn+1するコスト
	②前のメモリから、新しい番地にコピーするコスト
	③最後の要素に追加するコスト(無視していい)
	④元のを開放するコスト
reserve(n)
という関数があって、これは、あらかじめメモリを
予約しておく関数です。

resizeと違うのは、reserveしてもメモリが確保されるだけで
vectorの初期サイズはそのままです。

vectorとlistの違いって説明できますか。
①メモリが連続しているかしていないか
②listは要素の追加と削除のコストがvectorより安い
③vectorは探索コストがlistより安い
④ファイルの連続読み書きに使い場合じゃvector一択
	GPUbに投げるとか、メモリを塊として扱う場合には
	vectorしか使えない

←経験が少ないうちは「迷ったらvectorでいいよ」

STLのalgorithmの中には、条件に合致するものを削除する的な
便利な関数があったりします


algorithmのremove系の関数は、実際には削除しません
後ろに寄せているだけ
いらないものの先頭が戻り値として帰ってくるので、
実際に削除するには
it=remove系(～);
コンテナ.erase(it,コンテナ.end());



























