画面遷移をマネージャが一人でコントロールしているような
構造はやめましょう。

いろんなご意見ありますが、少なくとも就活のPGでは
「オブジェクト指向設計」の理解が求められるため
switchでシーンコントロールをするよりは

Stateパターンを使って実装したほうがポイント高いです。

参照
①一度初期化すると、参照先を変えれない
②必ず最初に初期化つまり参照先を設定しなければならない

参照にしようかポインタにしようか迷う場面がありますが、その場合は
null入れたいのか？→ポインタへ
最初に参照先が決まってない？→ポインタ
参照先が変わるかもしれない→ポインタ
これ以外に参照使えばいい

参照の初期化タイミング
①宣言の時にしか初期化できない
②メンバ変数の場合は「コンストラクタの初期化リスト」で初期化できる

関数の説明コメントはpublicに必ず書きましょう
privateは任意です。(ひとことコメント)

vectorやlistやmapの中身を巡回するための指定子としてiterator
というのがあります。こいつはvector.begin();の戻り値です。

実はリバースイテレータというのがあって、逆順に巡回するものがあります。
その場合はvector.rbegin()を使います。
なお、この場合、終端はvector.rend()です。++でさかのぼります

vectorやlistには、front()やback()という関数がありますが、
front()は先頭の要素の実体
back()は最後の要素の実体
です。

C++の仕様について…現代のC++のデファクトスタンダードは
clangです


後々キーコンフィグするために、Inputクラス内で、
生入力とゲーム中の指示に対して、ワンクッション置きます。

"next" : KEY_INPUT_RETURN
"pause" : KEY_INPUT_P


map系には罠があって
table["nanika"]
と書いた場合、2つの行動をとっています。
①この「キー」が存在するかどうか探す
	①あったらその値(value)を返す
	②なかったら、新しくキーと値を作る


状態遷移を扱う方法
①switch等で管理する
②Stateパターンを用いる
③メンバ関数ポインタを使う


　　待機　移動
待機　＼　　〇
移動　〇　　＼
JP　　〇　　


キャラアニメーションなどの小さい状態遷移に関しては
状態を関数とみなすことができる
攻撃中と待機中をフラグで管理するのではなく、現在
どの関数が実行されるべきなのか(状態)によって管理する
ことができます
この時の強い見方が、メンバ関数ポインタです



「遅延実行」をしたい場合は
コマンドバッファ的なものを使う。

関数を「今」ではなく、後ろの特定のタイミングで実行する

STLにはfunctionalというのがあります。

auto func = [クロージャ](引数){
	関数の内容
};

func();

