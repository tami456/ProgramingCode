マルチレンダーターゲット(1回のレンダリングで複数レンダーターゲットに
出力する)

DxLibでもできる。
DxLibのGraphFilterまわりは、シェーダやる前に知っておいたほうがいい。
シェーダでやると面倒な機能が最初っから搭載されていたりする

「ぼかし系は基本的に重い」範囲が広ければ広いほど重い
理由はぼかしという処理そのものにあって、

最も単純な平滑化フィルタでも
111
111
111
周囲の3×3ピクセルを加算して→最終的に正規化する
内部的にtex.Sample関数が1ピクセルにつき9回かかってる。
tex.Sample関数は、特定のテクスチャの特定の色を取得する関数です。
範囲が広くなればなるほど、当然とってくる色の数は多くなりそれだけ
「テクスチャフェッチ」が行われ、重くなります。
テクスチャフェッチとは、GPUメモリ上の特定のアドレスにレコードの針を
移動させること。

11111
11111
11111
11111
11111
増えれば増えるほど重くなる。これには悩まされてきた
ブルーム(グレア)は、結構広い範囲をぼかす必要があります。
このため、川瀬(SiliconStudio)という人が考えたのは
縮小バッファを用意しておく←この縮小バッファに対してぼかしを適用する

なので、広範囲にぼかしを適用したい場合は縮小バッファを使用する

例えば、グレアフィルタを使いたいなら、高輝度部分だけを抽出するために

①DX_GRAPH_FILTER_BRIGHT_CRIPで、特定輝度未満の部分を黒のα0で塗りつぶす
②縮小フィルタで1/2,1/4,1/8くらいを作っておく
③ガウスフィルタでそれぞれぼかす
④①②③をもとの画像に加算合成する



ノイズについて…
画像における乱数がノイズ
よく使う雲模様だとか、

シェーダ・ノイズで検索すると、このような式が出て起案す
frac(sin(dot(st.xy,float2(12.9898,78.233)) + seed) * 43758.5453123)
frac:1未満の値だけ抽出する
sin:正弦を返す
dot:内積を返す
→現在位置に従って、ランダム値を返してる。
ミソは、sinで出てきた値に対して、とんでもなくでかい値をかけて、それの小数点だけ
抽出している。
ただし、このやり方は微妙、そもそもfracで切り捨てられた
小数点以上がもったいない


乱数全般に関して
①rand()は乱数としての精度が低いので、ガチャなどに使ってはいけない
	乱数の精度が低いとは…パターンが出ちゃったり、
	予測できちゃったりする(コントロールできる)
	乱数の精度←予測できないこと(パターン化できないこと)
	rand()は「線形合同法」という単純なアルゴリズムでできています。
	非常に単純なアルゴリズムなだけにパターンが見えやすい
	→そもそもパターン的な、
	シューティングゲームやアクションゲームなどはこれで十分
②範囲の絞り込み
	よくあるのが、(rand()%max)+minとか、例えば2～8の範囲なら
	(rand%(8-2+1)) + 2 = (0～6)+2=2～8
	ただしこれも制度的にはあまりよくない。偏ってしまう。
	乱数が0～65535の範囲だとします。
	これを0～9の範囲内に収めたいとする。
	0～65536%10=0～5までの範囲の出る確率が、ちょっとだけ高い
	
→これらを改善するために出てきた後世のアルゴリズムは
mt19937,xorshiftがある
また、GetTickCount()などがあります。















