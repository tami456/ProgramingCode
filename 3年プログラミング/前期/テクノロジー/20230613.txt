マルチレンダ―ターゲット(1回のレンダリングで複数レンダーターゲットに
出力する)

DxLibでもそれはできます。
で、DxLibのGraphFilterまわりは、シェーダやる前に知っておいたほうがいい。
シェーダでやると面倒な機能が最初っから搭載されてたりする。

「ぼかし系は基本的に重いです」範囲が広ければ広い程重いです。
理由は暈しと言う処理そのものに合って、

最も単純な平滑化フィルタでも
111
111
111
周囲の3x3ピクセルを加算して→最終的に正規化する。
内部的にtex.Sample関数が1ピクセルにつき9回かかってる。
tex.Sample関数は、特定のテクスチャの特定の色を取得する関数です。
範囲が広くなればなるほど、当然取ってくる色の数は多くなりそれだけ
「テクスチャフェッチ」が行われ、重くなります。
テクスチャフェッチとは、GPUメモリ上の特定のアドレスにレコードのハリを
移動させること。

11111
11111
11111
11111
11111
このように増えれば増えるほど重くなる。だいぶこれには悩まされてきた。
ブルーム(グレア)は、結構広い範囲をぼかす必要があります。
このため、川瀬(SiliconStudio)って言う人が考えたのは…。
縮小バッファを用意しておく←この縮小バッファに対して暈しを適用する。

なので、※広範囲に暈しを適用したい場合は縮小バッファを使用する

例えば、グレアフィルタを使いたいなら、高輝度部分だけを抽出するために

①DX_GRAPH_FILTER_BRIGHT_CLIPで、特定輝度未満の部分を黒のα0で塗りつぶす。
②縮小フィルタで1/2,1/4,1/8くらいを作っておく
③ガウスフィルタでそれぞれぼかす
④①②③を元の画像に加算合成する



ノイズについて…
「えっ！？ノイズなんて使わねーよ。むしろ邪魔だろ？」

皆さん乱数使いますよね？画像における乱数がノイズだと思ってください。
「えっ？でも画像に乱数なんて使わねーだろ？」などと思うかもしれませんが、

よく使う雲模様であるとか、岩が割れる模様などに使用される。

シェーダ・ノイズで検索すると、このような式が出てきます。
frac(sin(dot(st.xy, float2(12.9898, 78.233)) + seed) * 43758.5453123);
frac:1未満の値だけ抽出する
sin:正弦を返す
dot:内積を返す。
→現在位置に従って、ランダム値を返してる。
ミソは、sinで出てきた値に対して、とんでもなくデカい値をかけて、それの小数点部分だけ
抽出している。

ただし、このやり方は、正直「なんで？」って思うし、そもそもfracで切り捨てられた
小数点以上がもったいない。


乱数全般に関して
①rand()は乱数としての精度が低いので、ガチャなどに使ってはイケナイ！！
	乱数の精度が低いとは…パターンが出ちゃったり、予測出来ちゃったりする(コントロールできる)
	乱数の精度←予測できない事(パターン化できない事)
	rand()は「線形合同法」という単純なアルゴリズムでできています。
	非常に単純なアルゴリズムなだけにパターンが見えやすい
	→そもそもがパターン的な、シューティングゲームやアクションゲームなどはこれで十分
②範囲の絞り込み
	よくあるのが、(rand()%(max-min+1))+minとか、例えば2～8の範囲なら
	(rand()%(8-2+1))+2=(0～6)+2=2～8
	ただしこれも精度的にはあまりよくない。偏ってしまう。乱数が0～65535の範囲だとします。
	これを0～9の範囲内に収めたいとする。
	0～65535%10=0～5までの範囲の出る確率が、ちょっとだけ高い。
③マルチスレッドの時には気を付けよう
	線形合同法のアルゴリズムは
	Xnext=(A*X+B)%M
	というものです。つまり、直前の値に依存します。
	この場合内部的に「グローバル変数」もしくは「static変数」を
	持っているはずなので、スレッドセーフではありません。
④srandの中にGetTickCountやtimeGetTimeを入れたりしますが、これも
	あまりよろしくない。

→これらを改善するために出てきた後世のアルゴリズムは
mt19937,xorshiftがある。
また、GetTickCount()などの場合、タイミングを合わせれば再現
可能だったりするので、std::random_deviceと言うものがあって
これは、実行速度が激遅ですが、ありとあらゆる要素を使って
ランダム値を作り出します(宇宙線など)、なので予測不能です。；

これらの事から一般的には、ランダムシードはrandom_deviceを使って
それぞれの乱数はmt19937やxorshiftを使用して生成します。




